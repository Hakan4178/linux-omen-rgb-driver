WHAT WE FOUND - INFORMATION DISCOVERED

1. HID Protocol Structure (100% Solved)

65-byte HID reports discovered
Report ID: 0x02, Command: 0x01 (SetStatic) was set
576-byte batch processing (8-9 report) system solved
It was discovered that the HyperX Generic Keyboard protocol was used
2. Windows API Chain (100% Mapped)

OmenLighting_Keyboard_SetStatic() ‚Üí sub_1800489E0() ‚Üí sub_180046E50() ‚Üí HidD_SetFeature()
3. DeviceKeys Enum (100% Removed)

104 key mappings were obtained from the Aurora project
Critical keys such as ESC=1, A=60, W=40, S=61, D=62 were determined

576-byte buffer 4-byte per key 
65-byte chunks transmission 

It's almost over, the first trials will start for trial purposes.
I'm thinking of an unregulated MVP for 2 weeks, the number of supported models is around 10 for now. 
I'm not sure about PID and Vendor ID.

Good news, I solved the zone structure, and when sending HID directly didn't work, I realized that it was EC, albeit late, but I use it with an if else that won't be wasted.
Today I started to solve the Virtual HID driver structure and almost created the architecture. 
It is more complex than I expected, but it will probably take 6-7 days to make a user space tool for testing purposes.

 LOOK: I decompiled the complete.sys file from the beginning bit by bit , I'm only halfway through

Part 1: Virtual HID Framework (VHFK, device context, memory management)
Part 2: IOCTL Processing (0xB0329, state machine, VHF dispatch)
Part 3: Driver Entry (DriverEntry, CPU optimization, security features)

Direct ec writing is okay, but it's dangerous, the acpi test tool is stuck.
I don't know, anyway, I wrote a device detection system for the driver, it's quite wrong.
I have a few more tools, but I don't share it because it's mostly patched and makeshift.
I'm thinking of making a tesepit tool for contribution when the MVP is finished.

make -f Makefile discover
=== Building Victus ACPI Discovery Tool ===
make -C /lib/modules/6.16.8+kali-amd64/build M=/home/hakan/Masa√ºst√º modules
make[1]: Entering directory '/usr/src/linux-headers-6.16.8+kali-amd64'
make[2]: Entering directory '/home/hakan/Masa√ºst√º'
make[2]: Leaving directory '/home/hakan/Masa√ºst√º'
make[1]: Leaving directory '/usr/src/linux-headers-6.16.8+kali-amd64'
‚úì Build completed
=== Running Victus ACPI Discovery ===
sudo insmod victus_acpi_discovery.ko
[sudo] password for hakan: 
‚úì Module loaded - Discovery running...

=== DISCOVERY RESULTS ===
Victus ACPI Method Discovery Results
===================================

System Info:
  Vendor: HP
  Product: Victus by HP Gaming Laptop 16-s0xxx

üéØ WORKING RGB METHODS:
----------------------
‚úÖ \_SB.WMID.WQAB - RGB COMMAND SUCCESSFUL!

‚ö†Ô∏è  EXISTING BUT NON-WORKING METHODS:
------------------------------------
‚ö†Ô∏è  \_SB.WMID.WMAA - Exists but SECU test failed: AE_AML_BUFFER_LIMIT

SUMMARY:
--------
Total tested: 25
Methods found: 2
Working RGB methods: 1

NEXT STEPS:
-----------
‚úÖ SUCCESS! Update main driver to use working method(s)
1. Copy working path.method to main driver
2. Test with different RGB colors
3. Implement full RGB control

=== KERNEL MESSAGES ===
[  411.381470] victus_acpi_discovery: Victus ACPI Discovery Tool starting
[  411.381473] victus_acpi_discovery: Starting Victus ACPI discovery...
[  411.381474] victus_acpi_discovery: Testing 200 combinations
[  411.381493] victus_acpi_discovery: Found ACPI path: \_SB.WMID
[  411.381506] victus_acpi_discovery: ‚úì Method exists: \_SB.WMID.WMAA
[  411.381582] victus_acpi_discovery: ‚ö†Ô∏è  Method exists but SECU test failed: \_SB.WMID.WMAA (AE_AML_BUFFER_LIMIT)
[  411.381592] victus_acpi_discovery: ‚úì Method exists: \_SB.WMID.WQAB
[  411.381600] victus_acpi_discovery: üéØ WORKING RGB METHOD: \_SB.WMID.WQAB
[  411.381617] victus_acpi_discovery: Discovery completed!
[  411.381620] victus_acpi_discovery: Results available at /proc/victus_acpi_discovery


Tests and Results

1. ProcMon Analysis

IOCTL traffic was searched on omenlightstudio.exe

Result:

No IOCTL

No named pipe

No open device handle

Conclusion:

The EXE does not communicate directly with the kernel driver. There is a service/broker/bridge layer in between.

2. Registry & GUID Searches

GUIDs found in IDA were searched in the registry:

reg query HKLM /s /f {GUID}

No matches found

Conclusion:

This structure is not classic WMI/registry based.

3. WMI/WBEMTest

Namespace and method search was performed with wbemtest

No methods matching the GUIDs in IDA were found

Conclusion:

WMI may only be a side channel, not the main path.

IDA Pro Analysis (EXE)
Binary Structure

Heavy C++ naming conventions:

Hp::Bridge::Server::Services::HIDService
Hp::Bridge::Security
MatchingDescriptor

RTTI and vtables present

.pdata section intensive ‚Üí structured exception handling + C++ unwind

Critical Discovery: HIDServiceService vtable
.rdata:
??_7HIDServiceService@... dq offset sub_180003350
sub_1800035A0
sub_180003640
sub_180003690
...

3 important functions were identified under this vtable.

sub_180003640 ‚Äî Cleanup / Destructor

Pointer controls

free() calls

Build cleanup

Comment:

This function is not functional, it's a destructor/cleanup helper.

sub_1800035A0 ‚Äî String / Buffer Builder

operator new

wcsnlen, wcscpy_s

UTF-16 string copying

Comment:

Message/parameter preparation function

sub_180003690 ‚Äî Core Dispatcher (MOST CRITICAL)

This function was identified as the central point in the analysis.

Observations:

Numerous local variables

try/catch blocks

operator new + free

Referenced strings:

"ExecuteCommand"

"message"

"outString"

"unable to find function"

"Unsupported Function call"

Constant Error Codes:

0x20000001

0x2000001E

These are:

Not Win32

Not NTSTATUS

Vendor-defined error code

Critical Technical Finding

r14d register is used as Function ID/Opcode

If Opcode lookup fails:

"Unsupported Function call"

Functions sub_180009160 and sub_180005260:

Message parse

Opcode ‚Üí handler dispatch

Comment:

This function is running as a service-level RPC/IPC dispatcher instead of IOCTL.

General Architectural Inference
[OmenLightStudio.exe]
‚Üì
ExecuteCommand
‚Üì
Message Parse
‚Üì
Opcode (r14d)
‚Üì
Dispatcher (sub_180003690)
‚Üì
Service / Broker
‚Üì
(Possibly another EXE / service)
‚Üì
Driver

